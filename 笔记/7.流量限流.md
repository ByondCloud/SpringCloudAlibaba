## 阈值类型

### QPS

就是每秒只能接收1条请求，如果超过了就直接拒绝

![image-20230416115338400](image/7.%E6%B5%81%E9%87%8F%E9%99%90%E6%B5%81/image-20230416115338400.png)

![image-20230416115405971](image/7.%E6%B5%81%E9%87%8F%E9%99%90%E6%B5%81/image-20230416115405971.png)

这样访问/testA这个资源的时候，每秒只能1次，超了就报错

![image-20230416115500488](image/7.%E6%B5%81%E9%87%8F%E9%99%90%E6%B5%81/image-20230416115500488.png)

这个设置是立即生效的，不需要重启任何服务



### 并发线程数

我们修改一下controller

```java
@GetMapping("/testA")
public String testA() {
    try {
        Thread.sleep(800);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return "-----testA";
}
```

![image-20230416120652435](image/7.%E6%B5%81%E9%87%8F%E9%99%90%E6%B5%81/image-20230416120652435.png)

当我们多次访问就会出现这种情况，这个是否报错取决于服务的处理时间

假如A请求先进入，等待0.8秒，在0.5秒的时候B请求也进入，则会报错



## 流控模式

 ### 直接

就是自己限流，上面的例子已经很好的说明了

### 关联

A服务达到阈值，那么就限制B服务

例如支付模块已经达到阈值了，那么就限流下单的模块

![image-20230416121350661](image/7.%E6%B5%81%E9%87%8F%E9%99%90%E6%B5%81/image-20230416121350661.png)

当B达到阈值，A限流

这里我们用postman来做压测

![image-20230416122334457](image/7.%E6%B5%81%E9%87%8F%E9%99%90%E6%B5%81/image-20230416122334457.png)

![image-20230416122344243](image/7.%E6%B5%81%E9%87%8F%E9%99%90%E6%B5%81/image-20230416122344243.png)

![image-20230416122441904](image/7.%E6%B5%81%E9%87%8F%E9%99%90%E6%B5%81/image-20230416122441904.png)

![image-20230416122517335](image/7.%E6%B5%81%E9%87%8F%E9%99%90%E6%B5%81/image-20230416122517335.png)

每0.3秒循环一次，循环30次

当postman在发送的时候，去访问A，发现A挂了，这个就是关联

### 链路

参考：https://blog.bestguo.top/journal/sentinel-flow/

链路流控，比如有 商品模块、购物车模块、支付模块，我要对购物车模块限流

```
   商品
  /    \
购物车  支付 
```

那么购物车模块的流量都来源于商品模块，就是限制商品模块的流量流入购物车模块

![image-20230416124541672](image/7.%E6%B5%81%E9%87%8F%E9%99%90%E6%B5%81/image-20230416124541672.png)

当你的商品模块去访问支付模块，则不受影响

在 sentinel 1.6 之后，链路的维护是关闭的，也就是合在一起（unify）的。需要在配置文件中配置一下。

```properties
spring.cloud.sntinel.web-context-unify=false # 默认不维护调用链路，关闭收敛
```

## 流控效果

### 快速失败

不讲

### Warm Up

预热

![image-20230416125507259](image/7.%E6%B5%81%E9%87%8F%E9%99%90%E6%B5%81/image-20230416125507259.png)

一开始的单机阈值为10 / 3  = 3

在5秒内慢慢升高到单机阈值10

这个主要是防止一开始就有大量的数据冲击服务，从而导致宕机



### 排队等待

![image-20230416130136286](image/7.%E6%B5%81%E9%87%8F%E9%99%90%E6%B5%81/image-20230416130136286.png)

适用于突发性的流量

以固定的时间间隔【这个取决于QPS】，让请求通过，如果请求到来时间离上次请求超过设定的时间，则直接通过，否则会计算预计通过时间，没超过就排队，超过了就拒绝请求

例如上面的设置，每秒处理5个请求，最大等待时间为5秒

注意：不支持QPS > 1000

